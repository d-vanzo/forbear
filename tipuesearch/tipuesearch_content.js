var tipuesearch = {"pages":[{"text":"forbear forbear forbear, Fortran (progress) B(~~e~~)ar environment forbear has e mute, pronce it like forbar . A KISS pure Fortran Library for building and running fancy progress bar forbear is a pure Fortran (KISS) library for building and running fancy progress bar for modern Fortran projects; forbear is Fortran 2008+ standard compliant; forbear is OOP designed; forbear is TDD developed; forbear is a Free, Open Source Project. Issues Compiler Support | What is forbear? | Main features | Copyrights | Documentation | Install | What is forbear? In Executing long-time running programs it could be helpful to display a progress bar with some informative data. forbear is designed to perform just this task, handle the progress and display it as the user specifications: forbear handles data related to the progress of a (long) time run giving an informative, pretty-formatted ouput for each time step (or accordingly a given frequency) as the user specifications. Go to Top Main features Bar Element-Based Structure: fully customizable elements: foreground color; background color; style; Bar Bar scale Progress Percentage Progress Speed Start-End Time ETA Adaptive ETA Reverse Bar Rotating Marker Static Prefix-Suffix Messages Dynamic Message Well Documented Test Driven Developed FOSS Any feature request is welcome. Go to Top Copyrights forbear is a Free and Open Source Software (FOSS), it is distributed under a very permissive multi-licensing system: selectable licenses are GPLv3 , BSD2-Clause , BSD3-Clause and MIT , feel free to select the license that best matches your workflow. Anyone is interest to use, to develop or to contribute to FORESEER is welcome. More details can be found on wiki . Go to Top Documentation Besides this README file the forbear documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . | A taster of forber | API documentation A Taste of forbear A minimal plate : program forbear_minimal !< **forbear** test. use , intrinsic :: iso_fortran_env , only : I4P => int32 , R8P => real64 use forbear , only : bar_object implicit none type ( bar_object ) :: bar real ( R8P ) :: x real ( R8P ) :: y integer ( I4P ) :: i integer ( I4P ) :: j x = 0._R8P call bar % initialize ( filled_char_string = '+' , prefix_string = 'progress |' , suffi_stringx = '| ' , add_progress_percent = . true .) call bar % start do i = 1 , 20 x = x + 0.05_R8P do j = 1 , 100000000 y = sqrt ( x ) ! just spend some times enddo call bar % update ( current = x ) enddo endprogram forbear_minimal That built and run provides: → ./forbear_minimal\nprogress | ++++++++++++++++++++++++++++ | 85 % Go to Top API documentation forbear library exposes only one class, namely the bar_object class, that is used to handle the progress of your runs. The bar_object class has the following public methods destroy initialize is_stdout_locked start update destroy method Signature pure subroutine destroy ( self ) It has not dummy arguments (except the bar_object self bound-passed). It destroys the bar, namely reset it to the minimal (safe) status. Examples use forbear type ( bar_obejct ) :: bar call bar % destroy initialize method Signature subroutine initialize ( self , & prefix_string , prefix_color_fg , prefix_color_bg , prefix_style , & suffix_string , suffix_color_fg , suffix_color_bg , suffix_style , & bracket_left_string , bracket_left_color_fg , bracket_left_color_bg , bracket_left_style , & bracket_right_string , bracket_right_color_fg , bracket_right_color_bg , bracket_right_style , & empty_char_string , empty_char_color_fg , empty_char_color_bg , empty_char_style , & filled_char_string , filled_char_color_fg , filled_char_color_bg , filled_char_style , & add_scale_bar , scale_bar_color_fg , scale_bar_color_bg , scale_bar_style , & add_progress_percent , progress_percent_color_fg , progress_percent_color_bg , progress_percent_style , & add_progress_speed , progress_speed_color_fg , progress_speed_color_bg , progress_speed_style , & add_date_time , date_time_color_fg , date_time_color_bg , date_time_style , & width , min_value , max_value , frequency ) This method initializes the bar accordingly to the user specifications. It has a huge list of dummy arguments because the bar is fully customizable. The meaning of the arguments (except the obvious passed self ) are: character ( len =* ), intent ( in ), optional :: prefix_string ! Prefix string. character ( len =* ), intent ( in ), optional :: prefix_color_fg ! Prefix foreground color. character ( len =* ), intent ( in ), optional :: prefix_color_bg ! Prefix background color. character ( len =* ), intent ( in ), optional :: prefix_style ! Prefix style. character ( len =* ), intent ( in ), optional :: suffix_string ! Suffix string. character ( len =* ), intent ( in ), optional :: suffix_color_fg ! Suffix foreground color. character ( len =* ), intent ( in ), optional :: suffix_color_bg ! Suffix background color. character ( len =* ), intent ( in ), optional :: suffix_style ! Suffix style. character ( len =* ), intent ( in ), optional :: bracket_left_string ! Left bracket string. character ( len =* ), intent ( in ), optional :: bracket_left_color_fg ! Left bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_left_color_bg ! Left bracket background color. character ( len =* ), intent ( in ), optional :: bracket_left_style ! Left bracket style. character ( len =* ), intent ( in ), optional :: bracket_right_string ! Right bracket string character ( len =* ), intent ( in ), optional :: bracket_right_color_fg ! Right bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_right_color_bg ! Right bracket background color. character ( len =* ), intent ( in ), optional :: bracket_right_style ! Right bracket style. character ( len = 1 ), intent ( in ), optional :: empty_char_string ! Empty char. character ( len =* ), intent ( in ), optional :: empty_char_color_fg ! Empty char foreground color. character ( len =* ), intent ( in ), optional :: empty_char_color_bg ! Empty char background color. character ( len =* ), intent ( in ), optional :: empty_char_style ! Empty char style. character ( len = 1 ), intent ( in ), optional :: filled_char_string ! Filled char. character ( len =* ), intent ( in ), optional :: filled_char_color_fg ! Filled char foreground color. character ( len =* ), intent ( in ), optional :: filled_char_color_bg ! Filled char background color. character ( len =* ), intent ( in ), optional :: filled_char_style ! Filled char style. logical , intent ( in ), optional :: add_scale_bar ! Add scale to the bar. character ( len =* ), intent ( in ), optional :: scale_bar_color_fg ! Scale bar foreground color. character ( len =* ), intent ( in ), optional :: scale_bar_color_bg ! Scale bar background color. character ( len =* ), intent ( in ), optional :: scale_bar_style ! Scale bar style. logical , intent ( in ), optional :: add_progress_percent ! Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_percent_color_fg ! Progress percent foreground color. character ( len =* ), intent ( in ), optional :: progress_percent_color_bg ! Progress percent background color. character ( len =* ), intent ( in ), optional :: progress_percent_style ! Progress percent style. logical , intent ( in ), optional :: add_progress_speed ! Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_speed_color_fg ! Progress speed foreground color. character ( len =* ), intent ( in ), optional :: progress_speed_color_bg ! Progress speed background color. character ( len =* ), intent ( in ), optional :: progress_speed_style ! Progress speed style. logical , intent ( in ), optional :: add_date_time ! Add date and time. character ( len =* ), intent ( in ), optional :: date_time_color_fg ! Date and time foreground color. character ( len =* ), intent ( in ), optional :: date_time_color_bg ! Date and time background color. character ( len =* ), intent ( in ), optional :: date_time_style ! Date and time style. integer ( I4P ), intent ( in ), optional :: width ! With of the bar. real ( R8P ), intent ( in ), optional :: min_value ! Minimum value. real ( R8P ), intent ( in ), optional :: max_value ! Maximum value. integer ( I4P ), intent ( in ), optional :: frequency ! Bar update frequency, in range `[1%,100%]`. Examples use forbear type ( bar_obejct ) :: bar ! initialize a bar that will have only the progress percentage counter call bar % initialize ( width = 0 , add_progress_percent = . true ., progress_percent_color_fg = 'yellow' ) ! initialize a very fancy bar with \"all batteries included\" call bar % initialize ( width = 32 , & bracket_left_string = '|' , bracket_left_color_fg = 'blue' , & empty_char_string = 'o' , empty_char_color_fg = 'blue' , empty_char_color_bg = 'white' , & filled_char_string = ' ' , filled_char_color_bg = 'blue' , & bracket_right_string = '|' , bracket_right_color_fg = 'blue' , & prefix_string = 'progress ' , prefix_color_fg = 'red' , & add_progress_percent = . true ., progress_percent_color_fg = 'yellow' , & add_progress_speed = . true ., progress_speed_color_fg = 'green' , & add_date_time = . true ., date_time_color_fg = 'magenta' , & add_scale_bar = . true ., scale_bar_color_fg = 'blue' , scale_bar_style = 'underline_on' ) Note that if you initialize the bar to have also the scale over the progress bar the bar's length must be at least 22 characters. is_stdout_locked method Signature pure function is_stdout_locked ( self ) result ( is_locked ) This functions return .true. if the bar had locked the standard output unit, namely if the bar had started to print progress data. As a matter of fact, forbear locks the standard output unit during its running because it refreshes the last terminal row where it has been started. The user should be use this function to check if printing on standard output is safe, otherwise the look and feel of the bar will be destroyed. Examples use forbear type ( bar_obejct ) :: bar if (. not . bar % is_stdout_locked ) then ! you can safely print to stdout... endif start method Signature subroutine start ( self ) This method must be invoked just before the time consuming work starts. It locks the standard output unit and initialize the bar output, e.g. if the user selected to add the bar scale it is printed into this method. Note that there is not an equivalent end method: the bar is supposed to end when the progress reaches (or overcome) the 100%, that is handled directly into the update method. use forbear type ( bar_obejct ) :: bar call bar % initialize call bar % start ! in the following the long time consuming work update method Signature subroutine update ( self , current ) This method updates the bar each time it is called (accordingly to the frequency set into the initialize method, 1 by default). It takes only one argument, namely current : it is the current progress expressed in real(real64) where real64 is the kind constant provided by the iso_fortran_env intrinsic module. The current progress is evaluated with respect the minimum and maximum values set into the initialize method, that by default are 0 and 1 respectively. Essentially, the progress is computed as progress = nint ( current / ( self % max_value - self % min_value ) * 100 ) The update method handles the bar update automatically: if it is the first call after the start method some useful data for the progress statistics are stored, while if the 100% progress is reached it automatically ends the bar smoothly. Examples use , intrinsic :: iso_fortran_env use forbear type ( bar_obejct ) :: bar call bar % initialize ( max_value = 2.1_real64 ) call bar % start ! in the following the long time consuming work, e.g. increase \"t\" up a limit t = t + Dt call bar % update ( current = t ) For a complete examples see fobear_test Install forbear is a Fortran library composed by several modules. Before download and compile the library you must check the requirements . To download and build the project two main ways are available: exploit the install script that can be downloaded here manually download and build : download build install script forbear ships a bash script (downloadable from here ) that is able to automatize the download and build steps. The script install.sh has the following usage: → ./install.sh\nInstall script of forbear\nUsage:\n\ninstall.sh --help | -?\n    Print this usage output and exit install.sh --download | -d <arg> [ --verbose | -v ] Download the project\n\n    --download | -d [ arg ] Download the project, arg = git | wget to download with git or wget respectively\n    --verbose | -v         Output verbose mode activation\n\ninstall.sh --build | -b <arg> [ --verbose | -v ] Build the project\n\n    --build | -b [ arg ] Build the project, arg = fobis | make | cmake to build with FoBiS.py, GNU Make or CMake respectively\n    --verbose | -v      Output verbose mode activation\n\nExamples:\n\ninstall.sh --download git\ninstall.sh --build make\ninstall.sh --download wget --build cmake The script does not cover all possibilities. The script operation modes are 2 ( collapsible into one-single-mode): download a new fresh-clone of the latest master-release by means of: git ; wget (also curl is necessary); build a fresh-clone project as static-linked library by means of: FoBiS.py ; GNU Make ; CMake ; you can mix any of the above combinations accordingly to the tools available. Typical usages are: # download and prepare the project by means of git and build with GNU Make install.sh --dowload git --build make # download and prepare the project by means of wget (curl) and build with CMake install.sh --dowload wget --build cmake # download and prepare the project by means of git and build with FoBiS.py install.sh --dowload git --build fobis manually download and build download To download all the available releases and utilities (fobos, license, readme, etc…), it can be convenient to clone whole the project: git clone https://github.com/szaghi/forbear cd forbear\ngit submodule update --init Alternatively, you can directly download a release from GitHub server, see the ChangeLog . build The most easy way to compile forbear is to use FoBiS.py within the provided fobos file. Consequently, it is strongly encouraged to install FoBiS.py . | Build by means of FoBiS | Build by means of GNU Make | Build by means of CMake | build by means of FoBiS FoBiS.py is a KISS tool for automatic building of modern Fortran projects. Providing very few options, FoBiS.py is able to build almost automatically complex Fortran projects with cumbersome inter-modules dependency. This removes the necessity to write complex makefile. Moreover, providing a very simple options file (in the FoBiS.py nomenclature indicated as fobos file) FoBiS.py can substitute the (ab)use of makefile for other project stuffs (build documentations, make project archive, etc…). forbear is shipped with a fobos file that can build the library in both static and shared forms and also build the Test_Driver program. The provided fobos file has several building modes. listing fobos building modes Typing: FoBiS.py build -lmodes the following message should be printed: The fobos file defines the following modes:\n - \"shared-gnu\" - \"static-gnu\" - \"test-driver-gnu\" - \"shared-gnu-debug\" - \"static-gnu-debug\" - \"test-driver-gnu-debug\" - \"shared-intel\" - \"static-intel\" - \"test-driver-intel\" - \"shared-intel-debug\" - \"static-intel-debug\" - \"test-driver-intel-debug\" The modes should be self-explicative: shared , static and test-driver are the modes for building (in release, optimized form) the shared and static versions of the library and the Test Driver program, respectively. The other 3 modes are the same, but in debug form instead of release one. -gnu use the GNU gfortran compiler while -intel the Intel one. building the library The shared or static directories are created accordingly to the form of the library built. The compiled objects and mod files are placed inside this directory, as well as the linked library. release shared library FoBiS.py build -mode shared-gnu release static library FoBiS.py build -mode static-gnu debug shared library FoBiS.py build -mode shared-gnu-debug debug static library FoBiS.py build -mode static-gnu-debug build by means of GNU Make Not yet supported. Build by means of CMake Not yet supported. Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" forbear "},{"text":"forbear project, Fortran (progress) B(e)ar environment. This File Depends On sourcefile~~forbear.f90~~EfferentGraph sourcefile~forbear.f90 forbear.f90 sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear_bar_object.f90->sourcefile~forbear.f90 sourcefile~forbear_kinds.f90 forbear_kinds.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear.f90 sourcefile~forbear_kinds.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_element_object.f90 sourcefile~forbear_element_object.f90->sourcefile~forbear_bar_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~forbear.f90~~AfferentGraph sourcefile~forbear.f90 forbear.f90 sourcefile~forbear_test.f90 forbear_test.F90 sourcefile~forbear.f90->sourcefile~forbear_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules forbear Source Code forbear.f90 Source Code !< **forbear** project, Fortran (progress) B(e)ar environment. module forbear !< **forbear** project, Fortran (progress) B(e)ar environment. use forbear_bar_object , only : bar_object use forbear_kinds , only : ASCII , UCS4 implicit none private public :: bar_object public :: ASCII public :: UCS4 endmodule forbear","tags":"","loc":"sourcefile/forbear.f90.html","title":"forbear.f90 – forbear"},{"text":"forbear project, definition of bar_object . This File Depends On sourcefile~~forbear_bar_object.f90~~EfferentGraph sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear_kinds.f90 forbear_kinds.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_element_object.f90 sourcefile~forbear_element_object.f90->sourcefile~forbear_bar_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~forbear_bar_object.f90~~AfferentGraph sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear.f90 forbear.f90 sourcefile~forbear_bar_object.f90->sourcefile~forbear.f90 sourcefile~forbear_test.f90 forbear_test.F90 sourcefile~forbear.f90->sourcefile~forbear_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules forbear_bar_object Source Code forbear_bar_object.F90 Source Code !< **forbear** project, definition of [[bar_object]]. module forbear_bar_object !< **forbear** project, definition of [[bar_object]]. use , intrinsic :: iso_fortran_env , only : I4P => int32 , I8P => int64 , R8P => real64 , stdout => output_unit use forbear_element_object , only : element_object use forbear_kinds , only : ASCII , UCS4 implicit none private public :: bar_object type :: bar_object !< Progress **bar** class. type ( element_object ) :: prefix !< Message prefixing the bar. type ( element_object ) :: suffix !< Message suffixing the bar. type ( element_object ) :: bracket_left !< Left bracket surrounding the bar. type ( element_object ) :: bracket_right !< Right bracket surrounding the bar. type ( element_object ) :: empty_char !< Characters used for empty bar. type ( element_object ) :: filled_char !< Characters used for filled bar. type ( element_object ) :: progress_percent !< Progress in percent. type ( element_object ) :: progress_speed !< Progress speed in percent. type ( element_object ) :: scale_bar !< Scale bar. type ( element_object ) :: date_time !< Date and time. integer ( I4P ) :: width !< With of the bar. real ( R8P ) :: min_value !< Minimum value. real ( R8P ) :: max_value !< Maximum value. integer ( I4P ) :: frequency !< Bar update frequency, in range `[1%,100%]`. logical :: add_scale_bar !< Add scale to the bar. logical :: add_progress_percent !< Add progress in percent. logical :: add_progress_speed !< Add progress speed in percent. logical :: add_date_time !< Add date and time. logical :: is_stdout_locked_ !< Flag to store standard output status. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy bar. procedure , pass ( self ) :: initialize !< Initialize bar. procedure , pass ( self ) :: is_stdout_locked !< Return status of standard output unit. procedure , pass ( self ) :: start !< Start bar. procedure , pass ( self ) :: update !< Update bar. ! public operators generic :: assignment ( = ) => assign_bar !< Overload `=` operator. ! private methods procedure , pass ( lhs ), private :: assign_bar !< Operator `=`. endtype bar_object contains ! public methods pure subroutine destroy ( self ) !< Destroy bar. class ( bar_object ), intent ( inout ) :: self !< Bar. call self % prefix % destroy call self % suffix % destroy call self % bracket_left % destroy call self % bracket_right % destroy call self % empty_char % destroy call self % filled_char % destroy call self % progress_percent % destroy call self % progress_speed % destroy call self % scale_bar % destroy call self % date_time % destroy self % width = 32 self % min_value = 0._R8P self % max_value = 1._R8P self % frequency = 1_I4P self % add_scale_bar = . false . self % add_progress_percent = . false . self % add_progress_speed = . false . self % add_date_time = . false . self % is_stdout_locked_ = . false . endsubroutine destroy subroutine initialize ( self , & prefix_string , prefix_color_fg , prefix_color_bg , prefix_style , & suffix_string , suffix_color_fg , suffix_color_bg , suffix_style , & bracket_left_string , bracket_left_color_fg , bracket_left_color_bg , bracket_left_style , & bracket_right_string , bracket_right_color_fg , bracket_right_color_bg , bracket_right_style , & empty_char_string , empty_char_color_fg , empty_char_color_bg , empty_char_style , & filled_char_string , filled_char_color_fg , filled_char_color_bg , filled_char_style , & add_scale_bar , scale_bar_color_fg , scale_bar_color_bg , scale_bar_style , & add_progress_percent , progress_percent_color_fg , progress_percent_color_bg , progress_percent_style , & add_progress_speed , progress_speed_color_fg , progress_speed_color_bg , progress_speed_style , & add_date_time , date_time_color_fg , date_time_color_bg , date_time_style , & width , min_value , max_value , frequency ) !< Initialize bar. class ( bar_object ), intent ( inout ) :: self !< Bar. class ( * ), intent ( in ), optional :: prefix_string !< Prefix string. character ( len =* ), intent ( in ), optional :: prefix_color_fg !< Prefix foreground color. character ( len =* ), intent ( in ), optional :: prefix_color_bg !< Prefix background color. character ( len =* ), intent ( in ), optional :: prefix_style !< Prefix style. class ( * ), intent ( in ), optional :: suffix_string !< Suffix string. character ( len =* ), intent ( in ), optional :: suffix_color_fg !< Suffix foreground color. character ( len =* ), intent ( in ), optional :: suffix_color_bg !< Suffix background color. character ( len =* ), intent ( in ), optional :: suffix_style !< Suffix style. class ( * ), intent ( in ), optional :: bracket_left_string !< Left bracket string. character ( len =* ), intent ( in ), optional :: bracket_left_color_fg !< Left bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_left_color_bg !< Left bracket background color. character ( len =* ), intent ( in ), optional :: bracket_left_style !< Left bracket style. class ( * ), intent ( in ), optional :: bracket_right_string !< Right bracket string character ( len =* ), intent ( in ), optional :: bracket_right_color_fg !< Right bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_right_color_bg !< Right bracket background color. character ( len =* ), intent ( in ), optional :: bracket_right_style !< Right bracket style. class ( * ), intent ( in ), optional :: empty_char_string !< Empty char. character ( len =* ), intent ( in ), optional :: empty_char_color_fg !< Empty char foreground color. character ( len =* ), intent ( in ), optional :: empty_char_color_bg !< Empty char background color. character ( len =* ), intent ( in ), optional :: empty_char_style !< Empty char style. class ( * ), intent ( in ), optional :: filled_char_string !< Filled char. character ( len =* ), intent ( in ), optional :: filled_char_color_fg !< Filled char foreground color. character ( len =* ), intent ( in ), optional :: filled_char_color_bg !< Filled char background color. character ( len =* ), intent ( in ), optional :: filled_char_style !< Filled char style. logical , intent ( in ), optional :: add_scale_bar !< Add scale to the bar. character ( len =* ), intent ( in ), optional :: scale_bar_color_fg !< Scale bar foreground color. character ( len =* ), intent ( in ), optional :: scale_bar_color_bg !< Scale bar background color. character ( len =* ), intent ( in ), optional :: scale_bar_style !< Scale bar style. logical , intent ( in ), optional :: add_progress_percent !< Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_percent_color_fg !< Progress percent foreground color. character ( len =* ), intent ( in ), optional :: progress_percent_color_bg !< Progress percent background color. character ( len =* ), intent ( in ), optional :: progress_percent_style !< Progress percent style. logical , intent ( in ), optional :: add_progress_speed !< Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_speed_color_fg !< Progress speed foreground color. character ( len =* ), intent ( in ), optional :: progress_speed_color_bg !< Progress speed background color. character ( len =* ), intent ( in ), optional :: progress_speed_style !< Progress speed style. logical , intent ( in ), optional :: add_date_time !< Add date and time. character ( len =* ), intent ( in ), optional :: date_time_color_fg !< Date and time foreground color. character ( len =* ), intent ( in ), optional :: date_time_color_bg !< Date and time background color. character ( len =* ), intent ( in ), optional :: date_time_style !< Date and time style. integer ( I4P ), intent ( in ), optional :: width !< With of the bar. real ( R8P ), intent ( in ), optional :: min_value !< Minimum value. real ( R8P ), intent ( in ), optional :: max_value !< Maximum value. integer ( I4P ), intent ( in ), optional :: frequency !< Bar update frequency, in range `[1%,100%]`. character ( len = :, kind = UCS4 ), allocatable :: empty_char_string_ !< Characters used for empty bar, local variable. character ( len = :, kind = UCS4 ), allocatable :: filled_char_string_ !< Characters used for filled bar, local variable. empty_char_string_ = '-' ; call set_char ( char_string_ = empty_char_string_ , char_string = empty_char_string ) filled_char_string_ = '=' ; call set_char ( char_string_ = filled_char_string_ , char_string = filled_char_string ) call self % destroy call self % prefix % initialize ( string = prefix_string , color_fg = prefix_color_fg , color_bg = prefix_color_bg , style = prefix_style ) call self % suffix % initialize ( string = suffix_string , color_fg = suffix_color_fg , color_bg = suffix_color_bg , style = suffix_style ) call self % bracket_left % initialize ( string = bracket_left_string , color_fg = bracket_left_color_fg , color_bg = bracket_left_color_bg ,& style = bracket_left_style ) call self % bracket_right % initialize ( string = bracket_right_string , color_fg = bracket_right_color_fg ,& color_bg = bracket_right_color_bg , style = bracket_right_style ) call self % empty_char % initialize ( string = empty_char_string_ , color_fg = empty_char_color_fg , color_bg = empty_char_color_bg ,& style = empty_char_style ) call self % filled_char % initialize ( string = filled_char_string_ , color_fg = filled_char_color_fg , color_bg = filled_char_color_bg ,& style = filled_char_style ) if ( present ( add_scale_bar )) self % add_scale_bar = add_scale_bar call self % scale_bar % initialize ( color_fg = scale_bar_color_fg , color_bg = scale_bar_color_bg , style = scale_bar_style ) if ( present ( add_progress_percent )) self % add_progress_percent = add_progress_percent call self % progress_percent % initialize ( color_fg = progress_percent_color_fg , color_bg = progress_percent_color_bg ,& style = progress_percent_style ) if ( present ( add_progress_speed )) self % add_progress_speed = add_progress_speed call self % progress_speed % initialize ( color_fg = progress_speed_color_fg , color_bg = progress_speed_color_bg ,& style = progress_speed_style ) if ( present ( add_date_time )) self % add_date_time = add_date_time call self % date_time % initialize ( color_fg = date_time_color_fg , color_bg = date_time_color_bg , style = date_time_style ) if ( present ( width )) self % width = width if ( present ( min_value )) self % min_value = min_value if ( present ( max_value )) self % max_value = max_value if ( present ( frequency )) self % frequency = frequency if ( self % add_scale_bar . and . self % width < 22 ) error stop 'error: for adding scale bar the bar width must be at least 22 chars' contains subroutine set_char ( char_string_ , char_string ) !< Set character accordingly to given `char_string`. character ( len = :, kind = UCS4 ), allocatable , intent ( inout ) :: char_string_ !< Character to be set. class ( * ), intent ( in ), optional :: char_string !< Given character. if ( present ( char_string )) then select type ( char_string ) #if defined ASCII_SUPPORTED && defined ASCII_NEQ_DEFAULT type is ( character ( len =* , kind = ASCII )) char_string_ = char_string #endif #ifdef UCS4_SUPPORTED type is ( character ( len =* , kind = UCS4 )) char_string_ = char_string #endif type is ( character ( len =* )) char_string_ = char_string endselect endif endsubroutine set_char endsubroutine initialize pure function is_stdout_locked ( self ) result ( is_locked ) !< Return status of standard output unit. class ( bar_object ), intent ( in ) :: self !< Bar. logical :: is_locked !< Standard output status. is_locked = self % is_stdout_locked_ endfunction is_stdout_locked subroutine start ( self ) !< Start bar. class ( bar_object ), intent ( inout ) :: self !< Bar. if ( self % add_scale_bar ) call add_scale_bar call self % update ( current = self % min_value ) self % is_stdout_locked_ = . true . contains subroutine add_scale_bar () !< Add scale to the bar. character ( len = :), allocatable :: bar !< Bar line. character ( len = 11 ) :: min_value !< Minimum_value. character ( len = 11 ) :: max_value !< Maximum_value. write ( min_value , '(F5.2)' ) self % min_value ; min_value = trim ( min_value ) // ' (min)' write ( max_value , '(F5.2)' ) self % max_value ; max_value = '(max) ' // trim ( max_value ) self % scale_bar % string = min_value // repeat ( ' ' , self % width - len ( min_value ) - len ( max_value )) // max_value bar = repeat ( UCS4_ ' ' , len ( self % prefix % string )) // self % bracket_left % output () // self % scale_bar % output () // & self % bracket_right % output () write ( stdout , '(A)' ) bar endsubroutine add_scale_bar endsubroutine start subroutine update ( self , current ) !< Update bar. class ( bar_object ), intent ( inout ) :: self !< Bar. real ( R8P ), intent ( in ) :: current !< Current value. integer ( I4P ) :: progress !< Progress, in percent. integer ( I4P ), save :: progress_previous !< Previous progress, in percent. integer ( I8P ), save :: tic_toc ( 1 : 2 ) !< Tic-toc timer. character ( len = 18 ), save :: date_time_start !< Start date/time. character ( len = 18 ) :: date_time !< Current date/time. integer ( I8P ) :: count_rate !< Timer count rate. integer ( I4P ) :: f_chars !< Number of filled characters of bar. character ( len = 4 , kind = UCS4 ) :: progress_percent !< Progress in percent. character ( len = 12 , kind = UCS4 ) :: progress_speed !< Progress speed in percent. character ( len = 1 , kind = UCS4 ), parameter :: bar_end = char ( 13 ) !< Last bar char, carriage return. character ( len = :, kind = UCS4 ), allocatable :: bar !< Bar line. progress = nint ( current / ( self % max_value - self % min_value ) * 100 ) if ( progress == 0 ) then progress_previous = 0 call system_clock ( tic_toc ( 1 ), count_rate ) if ( self % add_date_time ) call date_and_time ( date = date_time_start ( 1 : 8 ), time = date_time_start ( 9 :)) endif if ( mod ( progress , self % frequency ) == 0 . or . progress == 100 ) then call system_clock ( tic_toc ( 2 ), count_rate ) f_chars = nint ( progress / 10 0._R8P * self % width ) bar = self % prefix % output () bar = bar // self % bracket_left % output () bar = bar // repeat ( self % filled_char % output (), f_chars ) bar = bar // repeat ( self % empty_char % output (), self % width - f_chars ) bar = bar // self % bracket_right % output () bar = bar // self % suffix % output () if ( self % add_progress_percent ) then write ( progress_percent , '(I3,A)' ) progress , '%' self % progress_percent % string = progress_percent bar = bar // self % progress_percent % output () endif if ( self % add_progress_speed ) then write ( progress_speed , '(A,F6.2,A)' ) ' (' , ( progress - progress_previous ) / & ( real ( tic_toc ( 2 ) - tic_toc ( 1 ), kind = R8P ) / count_rate ), '%/s)' self % progress_speed % string = progress_speed bar = bar // self % progress_speed % output () endif bar = bar // bar_end write ( stdout , '(A)' , advance = 'no' ) bar flush ( stdout ) progress_previous = progress tic_toc ( 1 ) = tic_toc ( 2 ) endif if ( progress >= 100 ) then if ( self % add_date_time ) then call date_and_time ( date = date_time ( 1 : 8 ), time = date_time ( 9 :)) self % date_time % string = '[' // date_time_start ( 1 : 4 ) // '/' // date_time_start ( 5 : 6 ) // '/' // date_time_start ( 7 : 8 ) // & ' ' // date_time_start ( 9 : 10 ) // ':' // date_time_start ( 11 : 12 ) // ':' // date_time_start ( 13 : 14 ) // & ' - ' // date_time ( 1 : 4 ) // '/' // date_time ( 5 : 6 ) // '/' // date_time ( 7 : 8 ) // & ' ' // date_time ( 9 : 10 ) // ':' // date_time ( 11 : 12 ) // ':' // date_time ( 13 : 14 ) // ']' write ( stdout , '(A)' ) write ( stdout , '(A)' ) self % date_time % output () else write ( stdout , '(A)' ) endif self % is_stdout_locked_ = . false . endif endsubroutine update ! private methods pure subroutine assign_bar ( lhs , rhs ) !< Initialize bar. class ( bar_object ), intent ( inout ) :: lhs !< Left hand side. type ( bar_object ), intent ( in ) :: rhs !< Right hand side. lhs % prefix = rhs % prefix lhs % suffix = rhs % suffix lhs % bracket_left = rhs % bracket_left lhs % bracket_right = rhs % bracket_right lhs % empty_char = rhs % empty_char lhs % filled_char = rhs % filled_char lhs % progress_percent = rhs % progress_percent lhs % progress_speed = rhs % progress_speed lhs % scale_bar = rhs % scale_bar lhs % date_time = rhs % date_time lhs % width = rhs % width lhs % min_value = rhs % min_value lhs % max_value = rhs % max_value lhs % frequency = rhs % frequency lhs % add_scale_bar = rhs % add_scale_bar lhs % add_progress_percent = rhs % add_progress_percent lhs % add_progress_speed = rhs % add_progress_speed lhs % add_date_time = rhs % add_date_time lhs % is_stdout_locked_ = rhs % is_stdout_locked_ endsubroutine assign_bar endmodule forbear_bar_object","tags":"","loc":"sourcefile/forbear_bar_object.f90.html","title":"forbear_bar_object.F90 – forbear"},{"text":"forbear project, definition of element_object . This File Depends On sourcefile~~forbear_element_object.f90~~EfferentGraph sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_kinds.f90 forbear_kinds.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_element_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~forbear_element_object.f90~~AfferentGraph sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear_element_object.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear.f90 forbear.f90 sourcefile~forbear_bar_object.f90->sourcefile~forbear.f90 sourcefile~forbear_test.f90 forbear_test.F90 sourcefile~forbear.f90->sourcefile~forbear_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules forbear_element_object Source Code forbear_element_object.F90 Source Code !< **forbear** project, definition of [[element_object]]. module forbear_element_object !< **forbear** project, definition of [[element_object]]. use , intrinsic :: iso_fortran_env , only : I4P => int32 , R8P => real32 , stdout => output_unit use face , only : colorize use forbear_kinds , only : ASCII , UCS4 implicit none private public :: element_object type :: element_object !< Bar element class. character ( len = :, kind = UCS4 ), allocatable :: string !< Element string. character ( len = :), allocatable :: color_fg !< Foreground color. character ( len = :), allocatable :: color_bg !< Background color. character ( len = :), allocatable :: style !< Style. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy element. procedure , pass ( self ) :: initialize !< Initialize element. procedure , pass ( self ) :: output !< Return formatted output of element. ! public operators generic :: assignment ( = ) => assign_element !< Overload `=`. ! private methods procedure , pass ( lhs ), private :: assign_element !< Operator `=`. endtype element_object contains ! public methods pure subroutine destroy ( self ) !< Destroy element. class ( element_object ), intent ( inout ) :: self !< element. if ( allocated ( self % string )) deallocate ( self % string ) if ( allocated ( self % color_fg )) deallocate ( self % color_fg ) if ( allocated ( self % color_bg )) deallocate ( self % color_bg ) if ( allocated ( self % style )) deallocate ( self % style ) endsubroutine destroy pure subroutine initialize ( self , string , color_fg , color_bg , style ) !< Initialize element. class ( element_object ), intent ( inout ) :: self !< element. class ( * ), intent ( in ), optional :: string !< Element string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color. character ( len =* ), intent ( in ), optional :: color_bg !< Background color. character ( len =* ), intent ( in ), optional :: style !< Style. call self % destroy self % string = UCS4_ '' if ( present ( string )) then select type ( string ) #if defined ASCII_SUPPORTED && defined ASCII_NEQ_DEFAULT type is ( character ( len =* , kind = ASCII )) self % string = string #endif #ifdef UCS4_SUPPORTED type is ( character ( len =* , kind = UCS4 )) self % string = string #endif type is ( character ( len =* )) self % string = string endselect endif self % color_fg = '' ; if ( present ( color_fg )) self % color_fg = color_fg self % color_bg = '' ; if ( present ( color_bg )) self % color_bg = color_bg self % style = '' ; if ( present ( style )) self % style = style endsubroutine initialize pure function output ( self ) !< Return formatted output of element. class ( element_object ), intent ( in ) :: self !< element. character ( len = :, kind = UCS4 ), allocatable :: output !< Formatted output. output = colorize ( self % string , color_fg = self % color_fg , color_bg = self % color_bg , style = self % style ) endfunction output ! private methods pure subroutine assign_element ( lhs , rhs ) !< Operator `=`. class ( element_object ), intent ( inout ) :: lhs !< Left hand side. type ( element_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % string )) lhs % string = rhs % string if ( allocated ( rhs % color_fg )) lhs % color_fg = rhs % color_fg if ( allocated ( rhs % color_bg )) lhs % color_bg = rhs % color_bg if ( allocated ( rhs % style )) lhs % style = rhs % style endsubroutine assign_element endmodule forbear_element_object","tags":"","loc":"sourcefile/forbear_element_object.f90.html","title":"forbear_element_object.F90 – forbear"},{"text":"forbear project, definition of parametric kinds. Files Dependent On This One sourcefile~~forbear_kinds.f90~~AfferentGraph sourcefile~forbear_kinds.f90 forbear_kinds.F90 sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_element_object.f90 sourcefile~forbear.f90 forbear.f90 sourcefile~forbear_kinds.f90->sourcefile~forbear.f90 sourcefile~forbear_bar_object.f90->sourcefile~forbear.f90 sourcefile~forbear_element_object.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear_test.f90 forbear_test.F90 sourcefile~forbear.f90->sourcefile~forbear_test.f90 var pansourcefileforbear_kindsf90AfferentGraph = svgPanZoom('#sourcefileforbear_kindsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules forbear_kinds Source Code forbear_kinds.F90 Source Code !< **forbear** project, definition of parametric kinds. module forbear_kinds !< **forbear** project, definition of parametric kinds. implicit none private public :: ASCII public :: UCS4 #ifdef ASCII_SUPPORTED integer , parameter :: ASCII = selected_char_kind ( 'ascii' ) !< ASCII character set kind. #else integer , parameter :: ASCII = selected_char_kind ( 'default' ) !< ASCII character set kind. #endif #ifdef UCS4_SUPPORTED integer , parameter :: UCS4 = selected_char_kind ( 'iso_10646' ) !< Unicode character set kind. #else integer , parameter :: UCS4 = selected_char_kind ( 'default' ) !< Unicode character set kind. #endif endmodule forbear_kinds","tags":"","loc":"sourcefile/forbear_kinds.f90.html","title":"forbear_kinds.F90 – forbear"},{"text":"forbear test. This File Depends On sourcefile~~forbear_test.f90~~EfferentGraph sourcefile~forbear_test.f90 forbear_test.F90 sourcefile~forbear.f90 forbear.f90 sourcefile~forbear.f90->sourcefile~forbear_test.f90 sourcefile~forbear_bar_object.f90 forbear_bar_object.F90 sourcefile~forbear_bar_object.f90->sourcefile~forbear.f90 sourcefile~forbear_kinds.f90 forbear_kinds.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear.f90 sourcefile~forbear_kinds.f90->sourcefile~forbear_bar_object.f90 sourcefile~forbear_element_object.f90 forbear_element_object.F90 sourcefile~forbear_kinds.f90->sourcefile~forbear_element_object.f90 sourcefile~forbear_element_object.f90->sourcefile~forbear_bar_object.f90 var pansourcefileforbear_testf90EfferentGraph = svgPanZoom('#sourcefileforbear_testf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs forbear_minimal Source Code forbear_test.F90 Source Code !< **forbear** test. program forbear_minimal !< **forbear** test. use , intrinsic :: iso_fortran_env , only : I4P => int32 , R8P => real64 use forbear , only : bar_object , UCS4 implicit none type ( bar_object ) :: bar print * print '(A)' , 'Minimal bar' call bar % initialize () call worker print '(A)' , 'Only counter bar' call bar % initialize ( width = 0 , add_progress_percent = . true ., progress_percent_color_fg = 'yellow' ) call worker print '(A)' , 'Fancy ASCII bar' call bar % initialize ( width = 32 , & bracket_left_string = '|' , bracket_left_color_fg = 'blue' , & empty_char_string = 'o' , empty_char_color_fg = 'blue' , empty_char_color_bg = 'white' , & filled_char_string = ' ' , filled_char_color_bg = 'blue' , & bracket_right_string = '|' , bracket_right_color_fg = 'blue' , & prefix_string = 'progress ' , prefix_color_fg = 'red' , & add_progress_percent = . true ., progress_percent_color_fg = 'yellow' , & add_progress_speed = . true ., progress_speed_color_fg = 'green' , & add_date_time = . true ., date_time_color_fg = 'magenta' , & add_scale_bar = . true ., scale_bar_color_fg = 'blue' , scale_bar_style = 'underline_on' ) call worker #ifdef UCS4_SUPPORTED print '(A)' , 'Fancy UCS4 bar' call bar % initialize ( width = 32 , & bracket_left_string = '|' , bracket_left_color_fg = 'blue' , & empty_char_string = UCS4_ '⬜' , empty_char_color_fg = 'blue' , & filled_char_string = UCS4_ '⬛' , filled_char_color_fg = 'blue' , & bracket_right_string = '|' , bracket_right_color_fg = 'blue' , & prefix_string = 'ƥƦōƔƦĘşş ' , prefix_color_fg = 'red' , & add_progress_percent = . true ., progress_percent_color_fg = 'yellow' , & add_progress_speed = . true ., progress_speed_color_fg = 'green' ) call worker #endif contains subroutine worker !< The worker. real ( R8P ) :: x real ( R8P ) :: y integer ( I4P ) :: i integer ( I4P ) :: j call bar % start x = 0._R8P do i = 1 , 20 x = x + 0.05_R8P do j = 1 , 20000000 y = sqrt ( x ) ! just spend some times enddo call bar % update ( current = x ) enddo endsubroutine worker endprogram forbear_minimal","tags":"","loc":"sourcefile/forbear_test.f90.html","title":"forbear_test.F90 – forbear"},{"text":"type, public :: bar_object type~~bar_object~~InheritsGraph type~bar_object bar_object type~element_object element_object type~element_object->type~bar_object bracket_left, bracket_right, date_time, empty_char, filled_char, prefix, progress_percent, progress_speed, scale_bar, suffix var pantypebar_objectInheritsGraph = svgPanZoom('#typebar_objectInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Progress bar class. Variables add_date_time add_progress_percent add_progress_speed add_scale_bar bracket_left bracket_right date_time empty_char filled_char frequency is_stdout_locked_ max_value min_value prefix progress_percent progress_speed scale_bar suffix width Type-Bound Procedures assign_bar assignment(=) destroy initialize is_stdout_locked start update Source Code bar_object Components Type Visibility Attributes Name Initial logical, public :: add_date_time Add date and time. logical, public :: add_progress_percent Add progress in percent. logical, public :: add_progress_speed Add progress speed in percent. logical, public :: add_scale_bar Add scale to the bar. type( element_object ), public :: bracket_left Left bracket surrounding the bar. type( element_object ), public :: bracket_right Right bracket surrounding the bar. type( element_object ), public :: date_time Date and time. type( element_object ), public :: empty_char Characters used for empty bar. type( element_object ), public :: filled_char Characters used for filled bar. integer(kind=I4P), public :: frequency Bar update frequency, in range [1%,100%] . logical, public :: is_stdout_locked_ Flag to store standard output status. real(kind=R8P), public :: max_value Maximum value. real(kind=R8P), public :: min_value Minimum value. type( element_object ), public :: prefix Message prefixing the bar. type( element_object ), public :: progress_percent Progress in percent. type( element_object ), public :: progress_speed Progress speed in percent. type( element_object ), public :: scale_bar Scale bar. type( element_object ), public :: suffix Message suffixing the bar. integer(kind=I4P), public :: width With of the bar. Type-Bound Procedures procedure, private, pass(lhs) :: assign_bar Operator = . private pure subroutine assign_bar (lhs, rhs) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: lhs Left hand side. type( bar_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_bar Overload = operator. private pure subroutine assign_bar (lhs, rhs) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: lhs Left hand side. type( bar_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy bar. private pure subroutine destroy (self) Destroy bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. procedure, public, pass(self) :: initialize Initialize bar. private subroutine initialize (self, prefix_string, prefix_color_fg, prefix_color_bg, prefix_style, suffix_string, suffix_color_fg, suffix_color_bg, suffix_style, bracket_left_string, bracket_left_color_fg, bracket_left_color_bg, bracket_left_style, bracket_right_string, bracket_right_color_fg, bracket_right_color_bg, bracket_right_style, empty_char_string, empty_char_color_fg, empty_char_color_bg, empty_char_style, filled_char_string, filled_char_color_fg, filled_char_color_bg, filled_char_style, add_scale_bar, scale_bar_color_fg, scale_bar_color_bg, scale_bar_style, add_progress_percent, progress_percent_color_fg, progress_percent_color_bg, progress_percent_style, add_progress_speed, progress_speed_color_fg, progress_speed_color_bg, progress_speed_style, add_date_time, date_time_color_fg, date_time_color_bg, date_time_style, width, min_value, max_value, frequency) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. class(*), intent(in), optional :: prefix_string Prefix string. character(len=*), intent(in), optional :: prefix_color_fg Prefix foreground color. character(len=*), intent(in), optional :: prefix_color_bg Prefix background color. character(len=*), intent(in), optional :: prefix_style Prefix style. class(*), intent(in), optional :: suffix_string Suffix string. character(len=*), intent(in), optional :: suffix_color_fg Suffix foreground color. character(len=*), intent(in), optional :: suffix_color_bg Suffix background color. character(len=*), intent(in), optional :: suffix_style Suffix style. class(*), intent(in), optional :: bracket_left_string Left bracket string. character(len=*), intent(in), optional :: bracket_left_color_fg Left bracket foreground color. character(len=*), intent(in), optional :: bracket_left_color_bg Left bracket background color. character(len=*), intent(in), optional :: bracket_left_style Left bracket style. class(*), intent(in), optional :: bracket_right_string Right bracket string character(len=*), intent(in), optional :: bracket_right_color_fg Right bracket foreground color. character(len=*), intent(in), optional :: bracket_right_color_bg Right bracket background color. character(len=*), intent(in), optional :: bracket_right_style Right bracket style. class(*), intent(in), optional :: empty_char_string Empty char. character(len=*), intent(in), optional :: empty_char_color_fg Empty char foreground color. character(len=*), intent(in), optional :: empty_char_color_bg Empty char background color. character(len=*), intent(in), optional :: empty_char_style Empty char style. class(*), intent(in), optional :: filled_char_string Filled char. character(len=*), intent(in), optional :: filled_char_color_fg Filled char foreground color. character(len=*), intent(in), optional :: filled_char_color_bg Filled char background color. character(len=*), intent(in), optional :: filled_char_style Filled char style. logical, intent(in), optional :: add_scale_bar Add scale to the bar. character(len=*), intent(in), optional :: scale_bar_color_fg Scale bar foreground color. character(len=*), intent(in), optional :: scale_bar_color_bg Scale bar background color. character(len=*), intent(in), optional :: scale_bar_style Scale bar style. logical, intent(in), optional :: add_progress_percent Add progress in percent. character(len=*), intent(in), optional :: progress_percent_color_fg Progress percent foreground color. character(len=*), intent(in), optional :: progress_percent_color_bg Progress percent background color. character(len=*), intent(in), optional :: progress_percent_style Progress percent style. logical, intent(in), optional :: add_progress_speed Add progress in percent. character(len=*), intent(in), optional :: progress_speed_color_fg Progress speed foreground color. character(len=*), intent(in), optional :: progress_speed_color_bg Progress speed background color. character(len=*), intent(in), optional :: progress_speed_style Progress speed style. logical, intent(in), optional :: add_date_time Add date and time. character(len=*), intent(in), optional :: date_time_color_fg Date and time foreground color. character(len=*), intent(in), optional :: date_time_color_bg Date and time background color. character(len=*), intent(in), optional :: date_time_style Date and time style. integer(kind=I4P), intent(in), optional :: width With of the bar. real(kind=R8P), intent(in), optional :: min_value Minimum value. real(kind=R8P), intent(in), optional :: max_value Maximum value. integer(kind=I4P), intent(in), optional :: frequency Bar update frequency, in range [1%,100%] . procedure, public, pass(self) :: is_stdout_locked Return status of standard output unit. private pure function is_stdout_locked (self) result(is_locked) Return status of standard output unit. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(in) :: self Bar. Return Value logical Standard output status. procedure, public, pass(self) :: start Start bar. private subroutine start (self) Start bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. procedure, public, pass(self) :: update Update bar. private subroutine update (self, current) Update bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. real(kind=R8P), intent(in) :: current Current value. Source Code type :: bar_object !< Progress **bar** class. type ( element_object ) :: prefix !< Message prefixing the bar. type ( element_object ) :: suffix !< Message suffixing the bar. type ( element_object ) :: bracket_left !< Left bracket surrounding the bar. type ( element_object ) :: bracket_right !< Right bracket surrounding the bar. type ( element_object ) :: empty_char !< Characters used for empty bar. type ( element_object ) :: filled_char !< Characters used for filled bar. type ( element_object ) :: progress_percent !< Progress in percent. type ( element_object ) :: progress_speed !< Progress speed in percent. type ( element_object ) :: scale_bar !< Scale bar. type ( element_object ) :: date_time !< Date and time. integer ( I4P ) :: width !< With of the bar. real ( R8P ) :: min_value !< Minimum value. real ( R8P ) :: max_value !< Maximum value. integer ( I4P ) :: frequency !< Bar update frequency, in range `[1%,100%]`. logical :: add_scale_bar !< Add scale to the bar. logical :: add_progress_percent !< Add progress in percent. logical :: add_progress_speed !< Add progress speed in percent. logical :: add_date_time !< Add date and time. logical :: is_stdout_locked_ !< Flag to store standard output status. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy bar. procedure , pass ( self ) :: initialize !< Initialize bar. procedure , pass ( self ) :: is_stdout_locked !< Return status of standard output unit. procedure , pass ( self ) :: start !< Start bar. procedure , pass ( self ) :: update !< Update bar. ! public operators generic :: assignment ( = ) => assign_bar !< Overload `=` operator. ! private methods procedure , pass ( lhs ), private :: assign_bar !< Operator `=`. endtype bar_object","tags":"","loc":"type/bar_object.html","title":"bar_object – forbear "},{"text":"type, public :: element_object Bar element class. Inherited By type~~element_object~~InheritedByGraph type~element_object element_object type~bar_object bar_object type~element_object->type~bar_object bracket_left, bracket_right, date_time, empty_char, filled_char, prefix, progress_percent, progress_speed, scale_bar, suffix var pantypeelement_objectInheritedByGraph = svgPanZoom('#typeelement_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables color_bg color_fg string style Type-Bound Procedures assign_element assignment(=) destroy initialize output Source Code element_object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: color_bg Background color. character(len=:), public, allocatable :: color_fg Foreground color. character(kind=len=:,UCS4), public, allocatable :: string Element string. character(len=:), public, allocatable :: style Style. Type-Bound Procedures procedure, private, pass(lhs) :: assign_element Operator = . private pure subroutine assign_element (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: lhs Left hand side. type( element_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_element Overload = . private pure subroutine assign_element (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: lhs Left hand side. type( element_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: destroy Destroy element. private pure subroutine destroy (self) Destroy element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. procedure, public, pass(self) :: initialize Initialize element. private pure subroutine initialize (self, string, color_fg, color_bg, style) Initialize element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. class(*), intent(in), optional :: string Element string. character(len=*), intent(in), optional :: color_fg Foreground color. character(len=*), intent(in), optional :: color_bg Background color. character(len=*), intent(in), optional :: style Style. procedure, public, pass(self) :: output Return formatted output of element. private pure function output (self) Return formatted output of element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self element. Return Value character(kind=len=:,UCS4),\n  allocatable Formatted output. Source Code type :: element_object !< Bar element class. character ( len = :, kind = UCS4 ), allocatable :: string !< Element string. character ( len = :), allocatable :: color_fg !< Foreground color. character ( len = :), allocatable :: color_bg !< Background color. character ( len = :), allocatable :: style !< Style. contains ! public methods procedure , pass ( self ) :: destroy !< Destroy element. procedure , pass ( self ) :: initialize !< Initialize element. procedure , pass ( self ) :: output !< Return formatted output of element. ! public operators generic :: assignment ( = ) => assign_element !< Overload `=`. ! private methods procedure , pass ( lhs ), private :: assign_element !< Operator `=`. endtype element_object","tags":"","loc":"type/element_object.html","title":"element_object – forbear "},{"text":"private pure function is_stdout_locked(self) result(is_locked) Return status of standard output unit. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(in) :: self Bar. Return Value logical Standard output status. Source Code is_stdout_locked Source Code pure function is_stdout_locked ( self ) result ( is_locked ) !< Return status of standard output unit. class ( bar_object ), intent ( in ) :: self !< Bar. logical :: is_locked !< Standard output status. is_locked = self % is_stdout_locked_ endfunction is_stdout_locked","tags":"","loc":"proc/is_stdout_locked.html","title":"is_stdout_locked – forbear"},{"text":"private pure subroutine assign_bar(lhs, rhs) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: lhs Left hand side. type( bar_object ), intent(in) :: rhs Right hand side. Source Code assign_bar Source Code pure subroutine assign_bar ( lhs , rhs ) !< Initialize bar. class ( bar_object ), intent ( inout ) :: lhs !< Left hand side. type ( bar_object ), intent ( in ) :: rhs !< Right hand side. lhs % prefix = rhs % prefix lhs % suffix = rhs % suffix lhs % bracket_left = rhs % bracket_left lhs % bracket_right = rhs % bracket_right lhs % empty_char = rhs % empty_char lhs % filled_char = rhs % filled_char lhs % progress_percent = rhs % progress_percent lhs % progress_speed = rhs % progress_speed lhs % scale_bar = rhs % scale_bar lhs % date_time = rhs % date_time lhs % width = rhs % width lhs % min_value = rhs % min_value lhs % max_value = rhs % max_value lhs % frequency = rhs % frequency lhs % add_scale_bar = rhs % add_scale_bar lhs % add_progress_percent = rhs % add_progress_percent lhs % add_progress_speed = rhs % add_progress_speed lhs % add_date_time = rhs % add_date_time lhs % is_stdout_locked_ = rhs % is_stdout_locked_ endsubroutine assign_bar","tags":"","loc":"proc/assign_bar.html","title":"assign_bar – forbear"},{"text":"private pure subroutine destroy(self) Destroy bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. Source Code destroy Source Code pure subroutine destroy ( self ) !< Destroy bar. class ( bar_object ), intent ( inout ) :: self !< Bar. call self % prefix % destroy call self % suffix % destroy call self % bracket_left % destroy call self % bracket_right % destroy call self % empty_char % destroy call self % filled_char % destroy call self % progress_percent % destroy call self % progress_speed % destroy call self % scale_bar % destroy call self % date_time % destroy self % width = 32 self % min_value = 0._R8P self % max_value = 1._R8P self % frequency = 1_I4P self % add_scale_bar = . false . self % add_progress_percent = . false . self % add_progress_speed = . false . self % add_date_time = . false . self % is_stdout_locked_ = . false . endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – forbear"},{"text":"private subroutine initialize(self, prefix_string, prefix_color_fg, prefix_color_bg, prefix_style, suffix_string, suffix_color_fg, suffix_color_bg, suffix_style, bracket_left_string, bracket_left_color_fg, bracket_left_color_bg, bracket_left_style, bracket_right_string, bracket_right_color_fg, bracket_right_color_bg, bracket_right_style, empty_char_string, empty_char_color_fg, empty_char_color_bg, empty_char_style, filled_char_string, filled_char_color_fg, filled_char_color_bg, filled_char_style, add_scale_bar, scale_bar_color_fg, scale_bar_color_bg, scale_bar_style, add_progress_percent, progress_percent_color_fg, progress_percent_color_bg, progress_percent_style, add_progress_speed, progress_speed_color_fg, progress_speed_color_bg, progress_speed_style, add_date_time, date_time_color_fg, date_time_color_bg, date_time_style, width, min_value, max_value, frequency) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. class(*), intent(in), optional :: prefix_string Prefix string. character(len=*), intent(in), optional :: prefix_color_fg Prefix foreground color. character(len=*), intent(in), optional :: prefix_color_bg Prefix background color. character(len=*), intent(in), optional :: prefix_style Prefix style. class(*), intent(in), optional :: suffix_string Suffix string. character(len=*), intent(in), optional :: suffix_color_fg Suffix foreground color. character(len=*), intent(in), optional :: suffix_color_bg Suffix background color. character(len=*), intent(in), optional :: suffix_style Suffix style. class(*), intent(in), optional :: bracket_left_string Left bracket string. character(len=*), intent(in), optional :: bracket_left_color_fg Left bracket foreground color. character(len=*), intent(in), optional :: bracket_left_color_bg Left bracket background color. character(len=*), intent(in), optional :: bracket_left_style Left bracket style. class(*), intent(in), optional :: bracket_right_string Right bracket string character(len=*), intent(in), optional :: bracket_right_color_fg Right bracket foreground color. character(len=*), intent(in), optional :: bracket_right_color_bg Right bracket background color. character(len=*), intent(in), optional :: bracket_right_style Right bracket style. class(*), intent(in), optional :: empty_char_string Empty char. character(len=*), intent(in), optional :: empty_char_color_fg Empty char foreground color. character(len=*), intent(in), optional :: empty_char_color_bg Empty char background color. character(len=*), intent(in), optional :: empty_char_style Empty char style. class(*), intent(in), optional :: filled_char_string Filled char. character(len=*), intent(in), optional :: filled_char_color_fg Filled char foreground color. character(len=*), intent(in), optional :: filled_char_color_bg Filled char background color. character(len=*), intent(in), optional :: filled_char_style Filled char style. logical, intent(in), optional :: add_scale_bar Add scale to the bar. character(len=*), intent(in), optional :: scale_bar_color_fg Scale bar foreground color. character(len=*), intent(in), optional :: scale_bar_color_bg Scale bar background color. character(len=*), intent(in), optional :: scale_bar_style Scale bar style. logical, intent(in), optional :: add_progress_percent Add progress in percent. character(len=*), intent(in), optional :: progress_percent_color_fg Progress percent foreground color. character(len=*), intent(in), optional :: progress_percent_color_bg Progress percent background color. character(len=*), intent(in), optional :: progress_percent_style Progress percent style. logical, intent(in), optional :: add_progress_speed Add progress in percent. character(len=*), intent(in), optional :: progress_speed_color_fg Progress speed foreground color. character(len=*), intent(in), optional :: progress_speed_color_bg Progress speed background color. character(len=*), intent(in), optional :: progress_speed_style Progress speed style. logical, intent(in), optional :: add_date_time Add date and time. character(len=*), intent(in), optional :: date_time_color_fg Date and time foreground color. character(len=*), intent(in), optional :: date_time_color_bg Date and time background color. character(len=*), intent(in), optional :: date_time_style Date and time style. integer(kind=I4P), intent(in), optional :: width With of the bar. real(kind=R8P), intent(in), optional :: min_value Minimum value. real(kind=R8P), intent(in), optional :: max_value Maximum value. integer(kind=I4P), intent(in), optional :: frequency Bar update frequency, in range [1%,100%] . Source Code initialize Source Code subroutine initialize ( self , & prefix_string , prefix_color_fg , prefix_color_bg , prefix_style , & suffix_string , suffix_color_fg , suffix_color_bg , suffix_style , & bracket_left_string , bracket_left_color_fg , bracket_left_color_bg , bracket_left_style , & bracket_right_string , bracket_right_color_fg , bracket_right_color_bg , bracket_right_style , & empty_char_string , empty_char_color_fg , empty_char_color_bg , empty_char_style , & filled_char_string , filled_char_color_fg , filled_char_color_bg , filled_char_style , & add_scale_bar , scale_bar_color_fg , scale_bar_color_bg , scale_bar_style , & add_progress_percent , progress_percent_color_fg , progress_percent_color_bg , progress_percent_style , & add_progress_speed , progress_speed_color_fg , progress_speed_color_bg , progress_speed_style , & add_date_time , date_time_color_fg , date_time_color_bg , date_time_style , & width , min_value , max_value , frequency ) !< Initialize bar. class ( bar_object ), intent ( inout ) :: self !< Bar. class ( * ), intent ( in ), optional :: prefix_string !< Prefix string. character ( len =* ), intent ( in ), optional :: prefix_color_fg !< Prefix foreground color. character ( len =* ), intent ( in ), optional :: prefix_color_bg !< Prefix background color. character ( len =* ), intent ( in ), optional :: prefix_style !< Prefix style. class ( * ), intent ( in ), optional :: suffix_string !< Suffix string. character ( len =* ), intent ( in ), optional :: suffix_color_fg !< Suffix foreground color. character ( len =* ), intent ( in ), optional :: suffix_color_bg !< Suffix background color. character ( len =* ), intent ( in ), optional :: suffix_style !< Suffix style. class ( * ), intent ( in ), optional :: bracket_left_string !< Left bracket string. character ( len =* ), intent ( in ), optional :: bracket_left_color_fg !< Left bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_left_color_bg !< Left bracket background color. character ( len =* ), intent ( in ), optional :: bracket_left_style !< Left bracket style. class ( * ), intent ( in ), optional :: bracket_right_string !< Right bracket string character ( len =* ), intent ( in ), optional :: bracket_right_color_fg !< Right bracket foreground color. character ( len =* ), intent ( in ), optional :: bracket_right_color_bg !< Right bracket background color. character ( len =* ), intent ( in ), optional :: bracket_right_style !< Right bracket style. class ( * ), intent ( in ), optional :: empty_char_string !< Empty char. character ( len =* ), intent ( in ), optional :: empty_char_color_fg !< Empty char foreground color. character ( len =* ), intent ( in ), optional :: empty_char_color_bg !< Empty char background color. character ( len =* ), intent ( in ), optional :: empty_char_style !< Empty char style. class ( * ), intent ( in ), optional :: filled_char_string !< Filled char. character ( len =* ), intent ( in ), optional :: filled_char_color_fg !< Filled char foreground color. character ( len =* ), intent ( in ), optional :: filled_char_color_bg !< Filled char background color. character ( len =* ), intent ( in ), optional :: filled_char_style !< Filled char style. logical , intent ( in ), optional :: add_scale_bar !< Add scale to the bar. character ( len =* ), intent ( in ), optional :: scale_bar_color_fg !< Scale bar foreground color. character ( len =* ), intent ( in ), optional :: scale_bar_color_bg !< Scale bar background color. character ( len =* ), intent ( in ), optional :: scale_bar_style !< Scale bar style. logical , intent ( in ), optional :: add_progress_percent !< Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_percent_color_fg !< Progress percent foreground color. character ( len =* ), intent ( in ), optional :: progress_percent_color_bg !< Progress percent background color. character ( len =* ), intent ( in ), optional :: progress_percent_style !< Progress percent style. logical , intent ( in ), optional :: add_progress_speed !< Add progress in percent. character ( len =* ), intent ( in ), optional :: progress_speed_color_fg !< Progress speed foreground color. character ( len =* ), intent ( in ), optional :: progress_speed_color_bg !< Progress speed background color. character ( len =* ), intent ( in ), optional :: progress_speed_style !< Progress speed style. logical , intent ( in ), optional :: add_date_time !< Add date and time. character ( len =* ), intent ( in ), optional :: date_time_color_fg !< Date and time foreground color. character ( len =* ), intent ( in ), optional :: date_time_color_bg !< Date and time background color. character ( len =* ), intent ( in ), optional :: date_time_style !< Date and time style. integer ( I4P ), intent ( in ), optional :: width !< With of the bar. real ( R8P ), intent ( in ), optional :: min_value !< Minimum value. real ( R8P ), intent ( in ), optional :: max_value !< Maximum value. integer ( I4P ), intent ( in ), optional :: frequency !< Bar update frequency, in range `[1%,100%]`. character ( len = :, kind = UCS4 ), allocatable :: empty_char_string_ !< Characters used for empty bar, local variable. character ( len = :, kind = UCS4 ), allocatable :: filled_char_string_ !< Characters used for filled bar, local variable. empty_char_string_ = '-' ; call set_char ( char_string_ = empty_char_string_ , char_string = empty_char_string ) filled_char_string_ = '=' ; call set_char ( char_string_ = filled_char_string_ , char_string = filled_char_string ) call self % destroy call self % prefix % initialize ( string = prefix_string , color_fg = prefix_color_fg , color_bg = prefix_color_bg , style = prefix_style ) call self % suffix % initialize ( string = suffix_string , color_fg = suffix_color_fg , color_bg = suffix_color_bg , style = suffix_style ) call self % bracket_left % initialize ( string = bracket_left_string , color_fg = bracket_left_color_fg , color_bg = bracket_left_color_bg ,& style = bracket_left_style ) call self % bracket_right % initialize ( string = bracket_right_string , color_fg = bracket_right_color_fg ,& color_bg = bracket_right_color_bg , style = bracket_right_style ) call self % empty_char % initialize ( string = empty_char_string_ , color_fg = empty_char_color_fg , color_bg = empty_char_color_bg ,& style = empty_char_style ) call self % filled_char % initialize ( string = filled_char_string_ , color_fg = filled_char_color_fg , color_bg = filled_char_color_bg ,& style = filled_char_style ) if ( present ( add_scale_bar )) self % add_scale_bar = add_scale_bar call self % scale_bar % initialize ( color_fg = scale_bar_color_fg , color_bg = scale_bar_color_bg , style = scale_bar_style ) if ( present ( add_progress_percent )) self % add_progress_percent = add_progress_percent call self % progress_percent % initialize ( color_fg = progress_percent_color_fg , color_bg = progress_percent_color_bg ,& style = progress_percent_style ) if ( present ( add_progress_speed )) self % add_progress_speed = add_progress_speed call self % progress_speed % initialize ( color_fg = progress_speed_color_fg , color_bg = progress_speed_color_bg ,& style = progress_speed_style ) if ( present ( add_date_time )) self % add_date_time = add_date_time call self % date_time % initialize ( color_fg = date_time_color_fg , color_bg = date_time_color_bg , style = date_time_style ) if ( present ( width )) self % width = width if ( present ( min_value )) self % min_value = min_value if ( present ( max_value )) self % max_value = max_value if ( present ( frequency )) self % frequency = frequency if ( self % add_scale_bar . and . self % width < 22 ) error stop 'error: for adding scale bar the bar width must be at least 22 chars' contains subroutine set_char ( char_string_ , char_string ) !< Set character accordingly to given `char_string`. character ( len = :, kind = UCS4 ), allocatable , intent ( inout ) :: char_string_ !< Character to be set. class ( * ), intent ( in ), optional :: char_string !< Given character. if ( present ( char_string )) then select type ( char_string ) #if defined ASCII_SUPPORTED && defined ASCII_NEQ_DEFAULT type is ( character ( len =* , kind = ASCII )) char_string_ = char_string #endif #ifdef UCS4_SUPPORTED type is ( character ( len =* , kind = UCS4 )) char_string_ = char_string #endif type is ( character ( len =* )) char_string_ = char_string endselect endif endsubroutine set_char endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – forbear"},{"text":"private subroutine start(self) Start bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. Source Code start Source Code subroutine start ( self ) !< Start bar. class ( bar_object ), intent ( inout ) :: self !< Bar. if ( self % add_scale_bar ) call add_scale_bar call self % update ( current = self % min_value ) self % is_stdout_locked_ = . true . contains subroutine add_scale_bar () !< Add scale to the bar. character ( len = :), allocatable :: bar !< Bar line. character ( len = 11 ) :: min_value !< Minimum_value. character ( len = 11 ) :: max_value !< Maximum_value. write ( min_value , '(F5.2)' ) self % min_value ; min_value = trim ( min_value ) // ' (min)' write ( max_value , '(F5.2)' ) self % max_value ; max_value = '(max) ' // trim ( max_value ) self % scale_bar % string = min_value // repeat ( ' ' , self % width - len ( min_value ) - len ( max_value )) // max_value bar = repeat ( UCS4_ ' ' , len ( self % prefix % string )) // self % bracket_left % output () // self % scale_bar % output () // & self % bracket_right % output () write ( stdout , '(A)' ) bar endsubroutine add_scale_bar endsubroutine start","tags":"","loc":"proc/start.html","title":"start – forbear"},{"text":"private subroutine update(self, current) Update bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. real(kind=R8P), intent(in) :: current Current value. Source Code update Source Code subroutine update ( self , current ) !< Update bar. class ( bar_object ), intent ( inout ) :: self !< Bar. real ( R8P ), intent ( in ) :: current !< Current value. integer ( I4P ) :: progress !< Progress, in percent. integer ( I4P ), save :: progress_previous !< Previous progress, in percent. integer ( I8P ), save :: tic_toc ( 1 : 2 ) !< Tic-toc timer. character ( len = 18 ), save :: date_time_start !< Start date/time. character ( len = 18 ) :: date_time !< Current date/time. integer ( I8P ) :: count_rate !< Timer count rate. integer ( I4P ) :: f_chars !< Number of filled characters of bar. character ( len = 4 , kind = UCS4 ) :: progress_percent !< Progress in percent. character ( len = 12 , kind = UCS4 ) :: progress_speed !< Progress speed in percent. character ( len = 1 , kind = UCS4 ), parameter :: bar_end = char ( 13 ) !< Last bar char, carriage return. character ( len = :, kind = UCS4 ), allocatable :: bar !< Bar line. progress = nint ( current / ( self % max_value - self % min_value ) * 100 ) if ( progress == 0 ) then progress_previous = 0 call system_clock ( tic_toc ( 1 ), count_rate ) if ( self % add_date_time ) call date_and_time ( date = date_time_start ( 1 : 8 ), time = date_time_start ( 9 :)) endif if ( mod ( progress , self % frequency ) == 0 . or . progress == 100 ) then call system_clock ( tic_toc ( 2 ), count_rate ) f_chars = nint ( progress / 10 0._R8P * self % width ) bar = self % prefix % output () bar = bar // self % bracket_left % output () bar = bar // repeat ( self % filled_char % output (), f_chars ) bar = bar // repeat ( self % empty_char % output (), self % width - f_chars ) bar = bar // self % bracket_right % output () bar = bar // self % suffix % output () if ( self % add_progress_percent ) then write ( progress_percent , '(I3,A)' ) progress , '%' self % progress_percent % string = progress_percent bar = bar // self % progress_percent % output () endif if ( self % add_progress_speed ) then write ( progress_speed , '(A,F6.2,A)' ) ' (' , ( progress - progress_previous ) / & ( real ( tic_toc ( 2 ) - tic_toc ( 1 ), kind = R8P ) / count_rate ), '%/s)' self % progress_speed % string = progress_speed bar = bar // self % progress_speed % output () endif bar = bar // bar_end write ( stdout , '(A)' , advance = 'no' ) bar flush ( stdout ) progress_previous = progress tic_toc ( 1 ) = tic_toc ( 2 ) endif if ( progress >= 100 ) then if ( self % add_date_time ) then call date_and_time ( date = date_time ( 1 : 8 ), time = date_time ( 9 :)) self % date_time % string = '[' // date_time_start ( 1 : 4 ) // '/' // date_time_start ( 5 : 6 ) // '/' // date_time_start ( 7 : 8 ) // & ' ' // date_time_start ( 9 : 10 ) // ':' // date_time_start ( 11 : 12 ) // ':' // date_time_start ( 13 : 14 ) // & ' - ' // date_time ( 1 : 4 ) // '/' // date_time ( 5 : 6 ) // '/' // date_time ( 7 : 8 ) // & ' ' // date_time ( 9 : 10 ) // ':' // date_time ( 11 : 12 ) // ':' // date_time ( 13 : 14 ) // ']' write ( stdout , '(A)' ) write ( stdout , '(A)' ) self % date_time % output () else write ( stdout , '(A)' ) endif self % is_stdout_locked_ = . false . endif endsubroutine update","tags":"","loc":"proc/update.html","title":"update – forbear"},{"text":"private pure function output(self) Return formatted output of element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self element. Return Value character(kind=len=:,UCS4),\n  allocatable Formatted output. Calls proc~~output~~CallsGraph proc~output output colorize colorize proc~output->colorize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code output Source Code pure function output ( self ) !< Return formatted output of element. class ( element_object ), intent ( in ) :: self !< element. character ( len = :, kind = UCS4 ), allocatable :: output !< Formatted output. output = colorize ( self % string , color_fg = self % color_fg , color_bg = self % color_bg , style = self % style ) endfunction output","tags":"","loc":"proc/output.html","title":"output – forbear"},{"text":"private pure subroutine assign_element(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: lhs Left hand side. type( element_object ), intent(in) :: rhs Right hand side. Source Code assign_element Source Code pure subroutine assign_element ( lhs , rhs ) !< Operator `=`. class ( element_object ), intent ( inout ) :: lhs !< Left hand side. type ( element_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % string )) lhs % string = rhs % string if ( allocated ( rhs % color_fg )) lhs % color_fg = rhs % color_fg if ( allocated ( rhs % color_bg )) lhs % color_bg = rhs % color_bg if ( allocated ( rhs % style )) lhs % style = rhs % style endsubroutine assign_element","tags":"","loc":"proc/assign_element.html","title":"assign_element – forbear"},{"text":"private pure subroutine destroy(self) Destroy element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. Source Code destroy Source Code pure subroutine destroy ( self ) !< Destroy element. class ( element_object ), intent ( inout ) :: self !< element. if ( allocated ( self % string )) deallocate ( self % string ) if ( allocated ( self % color_fg )) deallocate ( self % color_fg ) if ( allocated ( self % color_bg )) deallocate ( self % color_bg ) if ( allocated ( self % style )) deallocate ( self % style ) endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – forbear"},{"text":"private pure subroutine initialize(self, string, color_fg, color_bg, style) Initialize element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. class(*), intent(in), optional :: string Element string. character(len=*), intent(in), optional :: color_fg Foreground color. character(len=*), intent(in), optional :: color_bg Background color. character(len=*), intent(in), optional :: style Style. Source Code initialize Source Code pure subroutine initialize ( self , string , color_fg , color_bg , style ) !< Initialize element. class ( element_object ), intent ( inout ) :: self !< element. class ( * ), intent ( in ), optional :: string !< Element string. character ( len =* ), intent ( in ), optional :: color_fg !< Foreground color. character ( len =* ), intent ( in ), optional :: color_bg !< Background color. character ( len =* ), intent ( in ), optional :: style !< Style. call self % destroy self % string = UCS4_ '' if ( present ( string )) then select type ( string ) #if defined ASCII_SUPPORTED && defined ASCII_NEQ_DEFAULT type is ( character ( len =* , kind = ASCII )) self % string = string #endif #ifdef UCS4_SUPPORTED type is ( character ( len =* , kind = UCS4 )) self % string = string #endif type is ( character ( len =* )) self % string = string endselect endif self % color_fg = '' ; if ( present ( color_fg )) self % color_fg = color_fg self % color_bg = '' ; if ( present ( color_bg )) self % color_bg = color_bg self % style = '' ; if ( present ( style )) self % style = style endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – forbear"},{"text":"subroutine worker() The worker. Arguments None Called By proc~~worker~~CalledByGraph proc~worker worker program~forbear_minimal forbear_minimal program~forbear_minimal->proc~worker Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code worker Source Code subroutine worker !< The worker. real ( R8P ) :: x real ( R8P ) :: y integer ( I4P ) :: i integer ( I4P ) :: j call bar % start x = 0._R8P do i = 1 , 20 x = x + 0.05_R8P do j = 1 , 20000000 y = sqrt ( x ) ! just spend some times enddo call bar % update ( current = x ) enddo endsubroutine worker","tags":"","loc":"proc/worker.html","title":"worker – forbear"},{"text":"Uses: forbear_bar_object forbear_kinds module~~forbear~~UsesGraph module~forbear forbear module~forbear_kinds forbear_kinds module~forbear_kinds->module~forbear module~forbear_bar_object forbear_bar_object module~forbear_kinds->module~forbear_bar_object module~forbear_element_object forbear_element_object module~forbear_kinds->module~forbear_element_object module~forbear_bar_object->module~forbear iso_fortran_env iso_fortran_env iso_fortran_env->module~forbear_bar_object iso_fortran_env->module~forbear_element_object module~forbear_element_object->module~forbear_bar_object face face face->module~forbear_element_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. forbear project, Fortran (progress) B(e)ar environment. Used By module~~forbear~~UsedByGraph module~forbear forbear program~forbear_minimal forbear_minimal module~forbear->program~forbear_minimal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/forbear.html","title":"forbear – forbear"},{"text":"Uses: iso_fortran_env forbear_element_object forbear_kinds module~~forbear_bar_object~~UsesGraph module~forbear_bar_object forbear_bar_object iso_fortran_env iso_fortran_env iso_fortran_env->module~forbear_bar_object module~forbear_element_object forbear_element_object iso_fortran_env->module~forbear_element_object module~forbear_element_object->module~forbear_bar_object module~forbear_kinds forbear_kinds module~forbear_kinds->module~forbear_bar_object module~forbear_kinds->module~forbear_element_object face face face->module~forbear_element_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. forbear project, definition of bar_object . Used By module~~forbear_bar_object~~UsedByGraph module~forbear_bar_object forbear_bar_object module~forbear forbear module~forbear_bar_object->module~forbear program~forbear_minimal forbear_minimal module~forbear->program~forbear_minimal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types bar_object Functions is_stdout_locked Subroutines assign_bar destroy initialize start update Derived Types type, public :: bar_object Progress bar class. Components Type Visibility Attributes Name Initial logical, public :: add_date_time Add date and time. logical, public :: add_progress_percent Add progress in percent. logical, public :: add_progress_speed Add progress speed in percent. logical, public :: add_scale_bar Add scale to the bar. type( element_object ), public :: bracket_left Left bracket surrounding the bar. type( element_object ), public :: bracket_right Right bracket surrounding the bar. type( element_object ), public :: date_time Date and time. type( element_object ), public :: empty_char Characters used for empty bar. type( element_object ), public :: filled_char Characters used for filled bar. integer(kind=I4P), public :: frequency Bar update frequency, in range [1%,100%] . logical, public :: is_stdout_locked_ Flag to store standard output status. real(kind=R8P), public :: max_value Maximum value. real(kind=R8P), public :: min_value Minimum value. type( element_object ), public :: prefix Message prefixing the bar. type( element_object ), public :: progress_percent Progress in percent. type( element_object ), public :: progress_speed Progress speed in percent. type( element_object ), public :: scale_bar Scale bar. type( element_object ), public :: suffix Message suffixing the bar. integer(kind=I4P), public :: width With of the bar. Type-Bound Procedures procedure, private, pass(lhs) :: assign_bar Operator = . generic, public :: assignment(=) => assign_bar Overload = operator. procedure, public, pass(self) :: destroy Destroy bar. procedure, public, pass(self) :: initialize Initialize bar. procedure, public, pass(self) :: is_stdout_locked Return status of standard output unit. procedure, public, pass(self) :: start Start bar. procedure, public, pass(self) :: update Update bar. Functions private pure function is_stdout_locked (self) result(is_locked) Return status of standard output unit. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(in) :: self Bar. Return Value logical Standard output status. Subroutines private pure subroutine assign_bar (lhs, rhs) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: lhs Left hand side. type( bar_object ), intent(in) :: rhs Right hand side. private pure subroutine destroy (self) Destroy bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. private subroutine initialize (self, prefix_string, prefix_color_fg, prefix_color_bg, prefix_style, suffix_string, suffix_color_fg, suffix_color_bg, suffix_style, bracket_left_string, bracket_left_color_fg, bracket_left_color_bg, bracket_left_style, bracket_right_string, bracket_right_color_fg, bracket_right_color_bg, bracket_right_style, empty_char_string, empty_char_color_fg, empty_char_color_bg, empty_char_style, filled_char_string, filled_char_color_fg, filled_char_color_bg, filled_char_style, add_scale_bar, scale_bar_color_fg, scale_bar_color_bg, scale_bar_style, add_progress_percent, progress_percent_color_fg, progress_percent_color_bg, progress_percent_style, add_progress_speed, progress_speed_color_fg, progress_speed_color_bg, progress_speed_style, add_date_time, date_time_color_fg, date_time_color_bg, date_time_style, width, min_value, max_value, frequency) Initialize bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. class(*), intent(in), optional :: prefix_string Prefix string. character(len=*), intent(in), optional :: prefix_color_fg Prefix foreground color. character(len=*), intent(in), optional :: prefix_color_bg Prefix background color. character(len=*), intent(in), optional :: prefix_style Prefix style. class(*), intent(in), optional :: suffix_string Suffix string. character(len=*), intent(in), optional :: suffix_color_fg Suffix foreground color. character(len=*), intent(in), optional :: suffix_color_bg Suffix background color. character(len=*), intent(in), optional :: suffix_style Suffix style. class(*), intent(in), optional :: bracket_left_string Left bracket string. character(len=*), intent(in), optional :: bracket_left_color_fg Left bracket foreground color. character(len=*), intent(in), optional :: bracket_left_color_bg Left bracket background color. character(len=*), intent(in), optional :: bracket_left_style Left bracket style. class(*), intent(in), optional :: bracket_right_string Right bracket string character(len=*), intent(in), optional :: bracket_right_color_fg Right bracket foreground color. character(len=*), intent(in), optional :: bracket_right_color_bg Right bracket background color. character(len=*), intent(in), optional :: bracket_right_style Right bracket style. class(*), intent(in), optional :: empty_char_string Empty char. character(len=*), intent(in), optional :: empty_char_color_fg Empty char foreground color. character(len=*), intent(in), optional :: empty_char_color_bg Empty char background color. character(len=*), intent(in), optional :: empty_char_style Empty char style. class(*), intent(in), optional :: filled_char_string Filled char. character(len=*), intent(in), optional :: filled_char_color_fg Filled char foreground color. character(len=*), intent(in), optional :: filled_char_color_bg Filled char background color. character(len=*), intent(in), optional :: filled_char_style Filled char style. logical, intent(in), optional :: add_scale_bar Add scale to the bar. character(len=*), intent(in), optional :: scale_bar_color_fg Scale bar foreground color. character(len=*), intent(in), optional :: scale_bar_color_bg Scale bar background color. character(len=*), intent(in), optional :: scale_bar_style Scale bar style. logical, intent(in), optional :: add_progress_percent Add progress in percent. character(len=*), intent(in), optional :: progress_percent_color_fg Progress percent foreground color. character(len=*), intent(in), optional :: progress_percent_color_bg Progress percent background color. character(len=*), intent(in), optional :: progress_percent_style Progress percent style. logical, intent(in), optional :: add_progress_speed Add progress in percent. character(len=*), intent(in), optional :: progress_speed_color_fg Progress speed foreground color. character(len=*), intent(in), optional :: progress_speed_color_bg Progress speed background color. character(len=*), intent(in), optional :: progress_speed_style Progress speed style. logical, intent(in), optional :: add_date_time Add date and time. character(len=*), intent(in), optional :: date_time_color_fg Date and time foreground color. character(len=*), intent(in), optional :: date_time_color_bg Date and time background color. character(len=*), intent(in), optional :: date_time_style Date and time style. integer(kind=I4P), intent(in), optional :: width With of the bar. real(kind=R8P), intent(in), optional :: min_value Minimum value. real(kind=R8P), intent(in), optional :: max_value Maximum value. integer(kind=I4P), intent(in), optional :: frequency Bar update frequency, in range [1%,100%] . private subroutine start (self) Start bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. private subroutine update (self, current) Update bar. Arguments Type Intent Optional Attributes Name class( bar_object ), intent(inout) :: self Bar. real(kind=R8P), intent(in) :: current Current value.","tags":"","loc":"module/forbear_bar_object.html","title":"forbear_bar_object – forbear"},{"text":"Uses: iso_fortran_env face forbear_kinds module~~forbear_element_object~~UsesGraph module~forbear_element_object forbear_element_object iso_fortran_env iso_fortran_env iso_fortran_env->module~forbear_element_object face face face->module~forbear_element_object module~forbear_kinds forbear_kinds module~forbear_kinds->module~forbear_element_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. forbear project, definition of element_object . Used By module~~forbear_element_object~~UsedByGraph module~forbear_element_object forbear_element_object module~forbear_bar_object forbear_bar_object module~forbear_element_object->module~forbear_bar_object module~forbear forbear module~forbear_bar_object->module~forbear program~forbear_minimal forbear_minimal module~forbear->program~forbear_minimal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types element_object Functions output Subroutines assign_element destroy initialize Derived Types type, public :: element_object Bar element class. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: color_bg Background color. character(len=:), public, allocatable :: color_fg Foreground color. character(kind=len=:,UCS4), public, allocatable :: string Element string. character(len=:), public, allocatable :: style Style. Type-Bound Procedures procedure, private, pass(lhs) :: assign_element Operator = . generic, public :: assignment(=) => assign_element Overload = . procedure, public, pass(self) :: destroy Destroy element. procedure, public, pass(self) :: initialize Initialize element. procedure, public, pass(self) :: output Return formatted output of element. Functions private pure function output (self) Return formatted output of element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(in) :: self element. Return Value character(kind=len=:,UCS4),\n  allocatable Formatted output. Subroutines private pure subroutine assign_element (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: lhs Left hand side. type( element_object ), intent(in) :: rhs Right hand side. private pure subroutine destroy (self) Destroy element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. private pure subroutine initialize (self, string, color_fg, color_bg, style) Initialize element. Arguments Type Intent Optional Attributes Name class( element_object ), intent(inout) :: self element. class(*), intent(in), optional :: string Element string. character(len=*), intent(in), optional :: color_fg Foreground color. character(len=*), intent(in), optional :: color_bg Background color. character(len=*), intent(in), optional :: style Style.","tags":"","loc":"module/forbear_element_object.html","title":"forbear_element_object – forbear"},{"text":"forbear project, definition of parametric kinds. Used By module~~forbear_kinds~~UsedByGraph module~forbear_kinds forbear_kinds module~forbear forbear module~forbear_kinds->module~forbear module~forbear_element_object forbear_element_object module~forbear_kinds->module~forbear_element_object module~forbear_bar_object forbear_bar_object module~forbear_kinds->module~forbear_bar_object program~forbear_minimal forbear_minimal module~forbear->program~forbear_minimal module~forbear_element_object->module~forbear_bar_object module~forbear_bar_object->module~forbear Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ASCII UCS4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: ASCII = selected_char_kind('default') ASCII character set kind. integer, public, parameter :: UCS4 = selected_char_kind('default') Unicode character set kind.","tags":"","loc":"module/forbear_kinds.html","title":"forbear_kinds – forbear"},{"text":"Uses: iso_fortran_env forbear program~~forbear_minimal~~UsesGraph program~forbear_minimal forbear_minimal iso_fortran_env iso_fortran_env iso_fortran_env->program~forbear_minimal module~forbear_bar_object forbear_bar_object iso_fortran_env->module~forbear_bar_object module~forbear_element_object forbear_element_object iso_fortran_env->module~forbear_element_object module~forbear forbear module~forbear->program~forbear_minimal module~forbear_kinds forbear_kinds module~forbear_kinds->module~forbear module~forbear_kinds->module~forbear_bar_object module~forbear_kinds->module~forbear_element_object module~forbear_bar_object->module~forbear module~forbear_element_object->module~forbear_bar_object face face face->module~forbear_element_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. forbear test. Calls program~~forbear_minimal~~CallsGraph program~forbear_minimal forbear_minimal proc~worker worker program~forbear_minimal->proc~worker Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables bar Subroutines worker Source Code forbear_minimal Variables Type Attributes Name Initial type( bar_object ) :: bar Subroutines subroutine worker () The worker. Arguments None Source Code program forbear_minimal !< **forbear** test. use , intrinsic :: iso_fortran_env , only : I4P => int32 , R8P => real64 use forbear , only : bar_object , UCS4 implicit none type ( bar_object ) :: bar print * print '(A)' , 'Minimal bar' call bar % initialize () call worker print '(A)' , 'Only counter bar' call bar % initialize ( width = 0 , add_progress_percent = . true ., progress_percent_color_fg = 'yellow' ) call worker print '(A)' , 'Fancy ASCII bar' call bar % initialize ( width = 32 , & bracket_left_string = '|' , bracket_left_color_fg = 'blue' , & empty_char_string = 'o' , empty_char_color_fg = 'blue' , empty_char_color_bg = 'white' , & filled_char_string = ' ' , filled_char_color_bg = 'blue' , & bracket_right_string = '|' , bracket_right_color_fg = 'blue' , & prefix_string = 'progress ' , prefix_color_fg = 'red' , & add_progress_percent = . true ., progress_percent_color_fg = 'yellow' , & add_progress_speed = . true ., progress_speed_color_fg = 'green' , & add_date_time = . true ., date_time_color_fg = 'magenta' , & add_scale_bar = . true ., scale_bar_color_fg = 'blue' , scale_bar_style = 'underline_on' ) call worker #ifdef UCS4_SUPPORTED print '(A)' , 'Fancy UCS4 bar' call bar % initialize ( width = 32 , & bracket_left_string = '|' , bracket_left_color_fg = 'blue' , & empty_char_string = UCS4_ '⬜' , empty_char_color_fg = 'blue' , & filled_char_string = UCS4_ '⬛' , filled_char_color_fg = 'blue' , & bracket_right_string = '|' , bracket_right_color_fg = 'blue' , & prefix_string = 'ƥƦōƔƦĘşş ' , prefix_color_fg = 'red' , & add_progress_percent = . true ., progress_percent_color_fg = 'yellow' , & add_progress_speed = . true ., progress_speed_color_fg = 'green' ) call worker #endif contains subroutine worker !< The worker. real ( R8P ) :: x real ( R8P ) :: y integer ( I4P ) :: i integer ( I4P ) :: j call bar % start x = 0._R8P do i = 1 , 20 x = x + 0.05_R8P do j = 1 , 20000000 y = sqrt ( x ) ! just spend some times enddo call bar % update ( current = x ) enddo endsubroutine worker endprogram forbear_minimal","tags":"","loc":"program/forbear_minimal.html","title":"forbear_minimal – forbear"}]}